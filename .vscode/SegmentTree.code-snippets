{
  "": {
    "prefix": "SegmentTree",
    "body": [
      "template<class T>",
      "struct SegmentTree {",
      "    /*-----------------------------------------------*/",
      "    struct Node {",
      "        // TODO",
      "        T sum;",
      "        // TODO",
      "        Node() : sum(0) {}",
      "        Node(T sum) : sum(sum) {}",
      "        ~Node() {}",
      "        static Node merge(const Node &a, const Node &b)",
      "        {",
      "            Node res;",
      "            // TODO",
      "            res.sum = a.sum + b.sum;",
      "            return res;",
      "        }",
      "        friend ostream& operator<<(ostream& os, Node &node)",
      "        {",
      "            os << \"(\" << ",
      "                \"Node\"",
      "            << \")\";",
      "            return os;",
      "        }",
      "    };",
      "",
      "    /*-----------------------------------------------*/",
      "",
      "    int n;",
      "    // TODO: default value for lazy[i]",
      "    const T DEFAULT_LAZY = -1;",
      "    vector<T> lazy;",
      "    vector<int> lo, hi;",
      "    vector<Node> tree;",
      "",
      "    void init(int i, int l, int r, vector<T> &_raw) ",
      "    {",
      "        lo[i] = l;",
      "        hi[i] = r;",
      "        if (l == r) ",
      "        {",
      "            // TODO",
      "            tree[i] = Node(_raw[l]);",
      "            return;",
      "        }",
      "        int mid = (l + r - 1) >> 1;",
      "        init(2 * i, l, mid, _raw);",
      "        init(2 * i + 1, mid + 1, r, _raw);",
      "        tree[i] = Node::merge(tree[2 * i], tree[2 * i + 1]);",
      "    }",
      "",
      "    SegmentTree(int _n, vector<T> &_raw) ",
      "    {",
      "        n = 4 * _n + 1;",
      "        lo.assign(n, 0);",
      "        hi.assign(n, 0);",
      "        lazy.assign(n, DEFAULT_LAZY);",
      "        tree.assign(n, Node());",
      "        init(1, 0, _n-1, _raw);",
      "    }",
      "",
      "    void propagate(int i) {",
      "        if (lazy[i] == DEFAULT_LAZY) return;",
      "        // TODO: update tree[i] with lazy[i]",
      "        if (lo[i] != hi[i])",
      "        {",
      "            // TODO: assign or change by amount?",
      "            lazy[2 * i] = lazy[i];",
      "            lazy[2 * i + 1] = lazy[i];",
      "        }",
      "        ",
      "        lazy[i] = DEFAULT_LAZY;",
      "    }",
      "",
      "    void update(int i, int l, int r, T val)",
      "    {",
      "        propagate(i);",
      "        if (hi[i] < l || r < lo[i]) ",
      "            return;",
      "        // update a range",
      "        if (l <= lo[i] && hi[i] <= r) {",
      "            // TODO: update lazy[i] using val",
      "            ",
      "            propagate(i);",
      "            return;",
      "        }",
      "        // update a single element",
      "        if (lo[i] == hi[i]) {",
      "            // TODO",
      "            return;",
      "        }",
      "        update(2 * i, l, r, val);",
      "        update(2 * i + 1, l, r, val);",
      "        tree[i] = Node::merge(tree[2 * i], tree[2 * i + 1]);",
      "    }",
      "",
      "    Node query(int i, int l, int r)",
      "    {",
      "        propagate(i);",
      "        if (hi[i] < l || r < lo[i]) ",
      "            return Node();",
      "        if (l <= lo[i] && hi[i] <= r) {",
      "            return tree[i];",
      "        }",
      "        Node left_tree = query(2 * i, l, r);",
      "        Node right_tree = query(2 * i + 1, l, r);",
      "        return Node::merge(left_tree, right_tree);",
      "    }",
      "};"
    ]
  }
}
